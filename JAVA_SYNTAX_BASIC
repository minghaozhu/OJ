1. Modifiers:
  access control modifiers : 
    private : class
    public: world
    protected: package & subclass
    default: package
  non- access modifiers:
    static / final/ abstract/ sychronized/ volatile
    
2.  Operators
  >>>  &= |= ^=
  
3. Generics <E> : E can ONLY be reference type, not primitive types
  static <E> void find ();
  
4. data type: int(32) , float(32) , double(64), byte(8) , short (16), long (64)
  float : 1 bit for sign，8 bits for exp，23 for number 
  2的23次方是8388608，即7位有效数字，精度（10进制）
  double： 1 bit for sign, 11 bits for exp, 52 for number
  2^52=4.5E15，15位，所以double的有效位数是15位
  
  Methods, obj.ValueOf(), obj.toString()
  a. xxxValue(),  example: byteValue(), booleanValue(), charValue();
  b. compareTo(),  return 0, +1 & -1 for numbers   /// return 0,  a positive , a negative for strings
  c. equals();
  d. valueOf(primitive types); 
  e. toString(); 
  f. parseInt();
  
  
5. String
  a.concat: s1.concat(s2)
          s1 + s2;
  b.
    printf(s1, format), print with format
    String sf = String.format(s1, format);
    System.out.println(sf);
    
  Methods:
  a. charAt();
  b. compareTo();   compareToIgnoreCase();
  c. concat();
  d. contentEquals(StringBuffer s)
  e. String copyValueOf(char [] s)    or  String copyValueOf(char [] s, int offset, int count);
  f. void getChars(int srcBegin, int srcEnd, char [] dstChars, int dstBegin)
      CharSequence sq = str.subSequence(begin, end);
      String sub = str.subString(begin, end)
      char[] toCharArray();
  g. boolean endsWith(String suffix)
  h. boolean startsWith(String prefix), startsWith(String prefix, int offset)
  i. boolean equals(); equalsIgnoreCase();
  j. int indexOf(int ch); int indexOf(int ch, int start), int indexOf(String s), int indexOf(String s, int start)
  k. int lastIndexOf(int ch), int lastIndexOf(int ch, int start), int lastIndexOf(String s), int lastIndexOf(String s, int start)
      // int start 仅仅是开始搜索的位置，s的位置可以超出int start
  l. boolean matches(String regex)
  m. string1.replace( char old, char new)
    string2.replaceAll( String regex, String new),   regex can be normal string
    string2.repalceFirst(String regex, String new)
  n. boolean regionMatches(boolean ignoreCase, int offset1, String target, int offset2, int len)
     boolean regionMatches(int offset1, String target, int offset2, int len)
  o. String [] string.split( String regex), string.split( String regex, int limit)
  p. toLowerCase(); toUpperCase();
  q. trim(); s1.trim()remove trailing and leading " "
  r. String static valueOf(primitive data);   String s1 = String.valueOf(123);
  
  6. Arrays
  static void fill( int [] a, int target)
  static void sort( int [] a )
  static void equals (int [] a, int [] b)
  static binarySearch(int [] a, int key)
  public static <T> List<T> asList(T... a)
  
  7. inheritance
  super.method();
  super.variable;
  super(variable); constructor
  instanceOf:   dog instanceOf Animal
8. overriding:
class Animal{
   public void move(){
      System.out.println("Animals can move");
   }
}
class Dog extends Animal{
   public void move(){
      System.out.println("Dogs can walk and run");
   }
   public void bark(){
      System.out.println("Dogs can bark");
   }
}

public class TestDog{
   public static void main(String args[]){
      Animal a = new Animal(); // Animal reference and object
      Animal b = new Dog(); // Animal reference but Dog object
      a.move();// runs the method in Animal class
      b.move();//Runs the method in Dog class, dynamic polymorphysm
      b.bark(); // compile error
   }
}

10. abstract vs interface
a. An interface is implicitly abstract. You do not need to use the abstract keyword while declaring an interface
b. Each method in an interface is also implicitly abstract, so the abstract keyword is not needed.
c. Methods in an interface are implicitly public.
d. interface has no constructors

Tagging interface : interface without method

11. Java data structures
a. vector:
