    // DP solution:
    // state definition:
    //       endHp[i][j], startHp[i][j] is the HP the knight has when leaving / entering room [i,j]
    // deriving the equation:  
    //       endHp[i][j] = startHp[i][j] + grid[i][j]  => startHp = endHp - grid
    //       endHp[i][j] = min(startHp[i+1][j], startHp[i][j+1])
    //       restrictions: endHp[i][j] >= 1  ; startHp[i][j] >= 1
    //       using  a>=b , a>=c  && b>=c =>  a>= max(b,c)
    // for last location: 
    //      start = (end - grid) >= (1 - grid) && start >= 1
    //      start >= max(1, 1-grid);   min: start = max(1, 1-grid)
    // for other location:
    //      min(startHp[i+1][j], startHp[i][j+1]) = startHp[i][j] + grid[i][j]   && startHp]i][j] >= 1
    //      startHp[i][j] >= max(1, min(startHp[i+1][j], startHp[i][j+1])- grid)
    //      min:  startHp[i][j] = max(1, min(startHp[i+1][j], startHp[i][j+1])- grid);
    // Space Optimization:
    public int calculateMinimumHP(int[][] grid)
    {
        if(grid == null || grid.length == 0 || grid[0] == null || grid[0].length == 0) return 0;
        int m = grid.length;
        int n = grid[0].length;
        int [] hp = new int [n];
        hp[n-1] = Math.max(1, 1 - grid[m-1][n-1]);
        for(int j = n-2; j >= 0; j--) {
            hp[j] = Math.max (1, hp[j+1]- grid[m-1][j]);
        }
        for(int i = m-2 ; i >= 0; i--) {
            hp[n-1] = Math.max(1, hp[n-1] -grid[i][n-1]);
            for(int j = n-2; j >= 0; j--)
            hp[j] = Math.max (1, Math.min(hp[j], hp[j+1]) - grid[i][j]);
        }
        return hp[0];
    }
